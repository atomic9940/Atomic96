import os
from os import system as ss
import random  # Added for random delays
ll = 'pip install'
try:
	from cfonts import render
except ModuleNotFoundError:
	ss(ll+' python-cfonts')
try:
    import requests
except ModuleNotFoundError:
    os.system("pip install requests")
from aiohttp import (
    ClientResponseError,
    ClientSession,
    ClientTimeout
)
from aiohttp_socks import ProxyConnector
from fake_useragent import FakeUserAgent
from datetime import datetime
from colorama import *
import asyncio, time, json, os, pytz
wib = pytz.timezone('Asia/Jakarta')

def clear():
	os.system('cls' if os.name == 'nt' else 'clear')

def tanggal():
	hari_ini = datetime.now(wib)
	tgl = hari_ini.strftime("%d-%m-%Y %H:%M:%S")
	return tgl

def logo():
	clear()
	t = render(text='S O L I X', font='block', colors=['red', 'white'], align='center')
	print(t)
	print(f"{Fore.GREEN+Style.BRIGHT}•{Style.RESET_ALL} Author   : {Fore.CYAN+Style.BRIGHT}DarkneszXploit{Style.RESET_ALL}")
	print(f"{Fore.GREEN+Style.BRIGHT}•{Style.RESET_ALL} Team     : {Fore.CYAN+Style.BRIGHT}AnonXploit{Style.RESET_ALL}")
	print(f"{Fore.GREEN+Style.BRIGHT}•{Style.RESET_ALL} Date     : {Fore.CYAN+Style.BRIGHT}{tanggal()}{Style.RESET_ALL}")
	print(f"{Fore.GREEN+Style.BRIGHT}•{Style.RESET_ALL} Location : {Fore.CYAN+Style.BRIGHT}Indonesia{Style.RESET_ALL}")
	print(f"{Fore.GREEN+Style.BRIGHT}•{Style.RESET_ALL} Note     : {Fore.YELLOW+Style.BRIGHT}Use With Caution And Responsibility!{Style.RESET_ALL}\n")

class Solix:
    def __init__(self) -> None:
        self.headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7",
            "Origin": "chrome-extension://ocanmekhhffgpiiambnjmlconhhfgolg",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "cross-site",
            "Sec-Fetch-Storage-Access": "active"
        }
        self.BASE_API = "https://api.solixdepin.net/api"
        self.ref_code = "99DqVgWH"
        self.proxies = []
        self.proxy_index = 0
        self.account_proxies = {}
        self.access_tokens = {}
        self.refresh_tokens = {}
        self.request_counter = {}  # Added for request throttling

    def log(self, message: str):
        print(f"[{Fore.CYAN + Style.BRIGHT}{tanggal()}{Style.RESET_ALL}] {message}")

    async def request(self, method: str, url: str, headers: dict = None, data: str = None, proxy: str = None, retries: int = 3):
        connector = None
        if proxy:
            try:
                proxy_url = proxy.strip()
                if "://" in proxy_url:
                    schema, rest = proxy_url.split("://", 1)
                    if "@" in rest:
                        auth, host_port = rest.split("@", 1)
                        if ":" in host_port:
                            host, port_str = host_port.split(":", 1)
                            port = int(port_str)
                            connector = ProxyConnector.from_url(f"{schema}://{auth}@{host}:{port}")
                        else:
                            connector = ProxyConnector.from_url(f"{schema}://{auth}@{host}")
                    else:
                        connector = ProxyConnector.from_url(proxy_url)
                else:
                    connector = ProxyConnector.from_url(f"http://{proxy_url}")

            except Exception as e:
                self.log(f"{Fore.RED + Style.BRIGHT}Error Creating Proxy Connector for {proxy}: {e}{Style.RESET_ALL}")
                connector = None

        async with ClientSession(connector=connector, headers=headers, timeout=ClientTimeout(total=60)) as session:
            for attempt in range(retries):
                try:
                    async with session.request(method, url, data=data) as response:
                        response.raise_for_status()
                        return await response.json()
                except ClientResponseError as e:
                    self.log(f"{Fore.RED + Style.BRIGHT}Client Response Error ({attempt + 1}/{retries}): {e.status} - {url} - Proxy: {proxy}{Style.RESET_ALL}")
                except Exception as e:
                    self.log(f"{Fore.RED + Style.BRIGHT}Request Error ({attempt + 1}/{retries}): {e} - {url} - Proxy: {proxy}{Style.RESET_ALL}")
                await asyncio.sleep(5)
        return None

    async def get_proxy(self, email: str, use_proxy: bool):
        if not use_proxy:
            return None
        if email not in self.account_proxies or self.account_proxies[email] is None:
            if self.proxies:
                self.account_proxies[email] = self.proxies[self.proxy_index % len(self.proxies)]
                self.proxy_index += 1
            else:
                return None
        return self.account_proxies[email]

    async def human_delay(self, min=2, max=15):
        """تأخير عشوائي مع ارتجاج لمحاكاة السلوك البشري"""
        delay = random.uniform(min, max) + random.uniform(-1, 3)
        await asyncio.sleep(max(0.5, delay))
    
    async def rotate_user_agent(self):
        """تغيير User-Agent عشوائياً لكل طلب"""
        self.headers["User-Agent"] = FakeUserAgent().random

    async def load_proxies(self, use_proxy_choice: int):
        filename = "proxy.txt"
        try:
            if use_proxy_choice == 1:
                async with ClientSession(timeout=ClientTimeout(total=30)) as session:
                    async with session.get("https://raw.githubusercontent.com/monosans/proxy-list/main/proxies/all.txt") as response:
                        response.raise_for_status()
                        content = await response.text()
                        with open(filename, 'w') as f:
                            f.write(content)
                        self.proxies = content.splitlines()
                        random.shuffle(self.proxies)  # خلط البروكسيات عشوائياً
            else:
                if not os.path.exists(filename):
                    self.log(f"{Fore.RED + Style.BRIGHT}File {filename} Not Found.{Style.RESET_ALL}")
                    return
                with open(filename, 'r') as f:
                    self.proxies = f.read().splitlines()
                    random.shuffle(self.proxies)  # خلط البروكسيات عشوائياً
            
            if not self.proxies:
                self.log(f"{Fore.RED + Style.BRIGHT}No Proxies Found.{Style.RESET_ALL}")
                return

            self.log(
                f"{Fore.GREEN + Style.BRIGHT}Proxies Total  : {Style.RESET_ALL}"
                f"{Fore.WHITE + Style.BRIGHT}{len(self.proxies)}{Style.RESET_ALL}"
            )
        
        except Exception as e:
            self.log(f"{Fore.RED + Style.BRIGHT}Failed To Load Proxies: {e}{Style.RESET_ALL}")
            self.proxies = []

    async def rate_limit_check(self, email):
        """التحكم في معدل الطلبات لكل حساب"""
        if email not in self.request_counter:
            self.request_counter[email] = {
                'count': 0,
                'last_reset': time.time()
            }
        
        now = time.time()
        if now - self.request_counter[email]['last_reset'] > 3600:  # إعادة الضبط كل ساعة
            self.request_counter[email] = {
                'count': 0,
                'last_reset': now
            }
        
        self.request_counter[email]['count'] += 1
        if self.request_counter[email]['count'] > 50:  # الحد الأقصى 50 طلب/ساعة
            await asyncio.sleep(random.uniform(30, 120))  # تأخير طويل إذا تجاوز الحد

    async def auth_login(self, email: str, password: str, proxy=None, retries=5):
        await self.rate_limit_check(email)
        await self.rotate_user_agent()
        await self.human_delay()
        
        url = f"{self.BASE_API}/auth/login-password"
        data = json.dumps({"email":email,"referralByCode":self.ref_code,"captchaToken":"","password":password})
        headers = {
            **self.headers,
            "Content-Length": str(len(data)),
            "Content-Type": "application/json"
        }
        for attempt in range(retries):
            res = await self.request("POST", url, headers=headers, data=data, proxy=proxy)
            if res and "accessToken" in res:
                return res["data"]
            await asyncio.sleep(5)
        return None

    async def auth_refresh(self, email: str, password: str, use_proxy: bool, proxy=None, retries=5):
        await self.rate_limit_check(email)
        await self.rotate_user_agent()
        await self.human_delay()
        
        url = f"{self.BASE_API}/auth/refresh"
        headers = {
            **self.headers,
            "Authorization": f"Bearer {self.refresh_tokens[email]}",
            "Content-Type": "application/json"
        }
        data = json.dumps({"refreshToken": self.refresh_tokens[email]})
        for attempt in range(retries):
            res = await self.request("POST", url, headers=headers, data=data, proxy=proxy)
            if res and "accessToken" in res:
                return res["data"]
            elif res and res.get("message") == "Unauthorized":
                await self.process_user_login(email, password, use_proxy)
                headers["Authorization"] = f"Bearer {self.refresh_tokens[email]}"
                data = json.dumps({"refreshToken": self.refresh_tokens[email]})
                continue
            await asyncio.sleep(5)
        return None

    async def get_total_point(self, email: str, proxy=None, retries=5):
        await self.rate_limit_check(email)
        await self.rotate_user_agent()
        await self.human_delay(3, 7)
        
        url = f"{self.BASE_API}/point/get-total-point"
        headers = {
            **self.headers,
            "Authorization": f"Bearer {self.access_tokens[email]}"
        }
        for attempt in range(retries):
            res = await self.request("GET", url, headers=headers, proxy=proxy)
            if res and "total" in res:
                return res
            await asyncio.sleep(5)
        return None

    async def get_connection_quality(self, email: str, proxy=None, retries=5):
        await self.rate_limit_check(email)
        await self.rotate_user_agent()
        await self.human_delay(3, 7)
        
        url = f"{self.BASE_API}/point/get-connection-quality"
        headers = {
            **self.headers,
            "Authorization": f"Bearer {self.access_tokens[email]}"
        }
        for attempt in range(retries):
            res = await self.request("GET", url, headers=headers, proxy=proxy)
            if res and "data" in res:
                return res
            await asyncio.sleep(5)
        return None

    async def get_user_task(self, email: str, proxy=None, retries=5):
        await self.rate_limit_check(email)
        await self.rotate_user_agent()
        await self.human_delay(5, 10)
        
        url = f"{self.BASE_API}/task/get-user-task"
        headers = {
            **self.headers,
            "Authorization": f"Bearer {self.access_tokens[email]}"
        }
        for attempt in range(retries):
            res = await self.request("GET", url, headers=headers, proxy=proxy)
            if res and "data" in res:
                return res
            await asyncio.sleep(5)
        return None

    async def perform_task(self, email: str, task_id: str, proxy=None, retries=5):
        await self.rate_limit_check(email)
        await self.rotate_user_agent()
        await self.human_delay(8, 18)
        
        url = f"{self.BASE_API}/task/do-task"
        data = json.dumps({"taskId":task_id})
        headers = {
            **self.headers,
            "Authorization": f"Bearer {self.access_tokens[email]}",
            "Content-Type": "application/json"
        }
        for attempt in range(retries):
            res = await self.request("POST", url, headers=headers, data=data, proxy=proxy)
            if res and res.get("result") == "success":
                return res
            await asyncio.sleep(5)
        return None

    async def claim_task(self, email: str, task_id: str, proxy=None, retries=5):
        await self.rate_limit_check(email)
        await self.rotate_user_agent()
        await self.human_delay(6, 16)
        
        url = f"{self.BASE_API}/task/claim-task"
        data = json.dumps({"taskId":task_id})
        headers = {
            **self.headers,
            "Authorization": f"Bearer {self.access_tokens[email]}",
            "Content-Type": "application/json"
        }
        for attempt in range(retries):
            res = await self.request("POST", url, headers=headers, data=data, proxy=proxy)
            if res and res.get("result") == "success":
                return res
            await asyncio.sleep(5)
        return None

    async def start_earn_point(self, email: str, proxy=None, retries=5):
        await self.rate_limit_check(email)
        await self.rotate_user_agent()
        await self.human_delay(10, 25)
        
        url = f"{self.BASE_API}/point/start-earn-point"
        headers = {
            **self.headers,
            "Authorization": f"Bearer {self.access_tokens[email]}"
        }
        for attempt in range(retries):
            res = await self.request("POST", url, headers=headers, proxy=proxy)
            if res and res.strip() == "true":
                return res
            await asyncio.sleep(5)
        return None

    async def process_user_login(self, email: str, password: str, use_proxy: bool):
        proxy = await self.get_proxy(email, use_proxy)
        token_data = await self.auth_login(email, password, proxy)
        if token_data:
            self.access_tokens[email] = token_data["accessToken"]
            self.refresh_tokens[email] = token_data["refreshToken"]
            self.log(f"{Fore.GREEN + Style.BRIGHT}Login Success for {email} (Proxy: {proxy if proxy else 'No Proxy'}){Style.RESET_ALL}")
            return self.access_tokens[email], self.refresh_tokens[email]
        else:
            self.log(f"{Fore.RED + Style.BRIGHT}Login Failed for {email} (Proxy: {proxy if proxy else 'No Proxy'}){Style.RESET_ALL}")
            return None, None

    async def process_refreshing_token(self, email: str, password: str, use_proxy: bool):
        while True:
            await asyncio.sleep(3500
